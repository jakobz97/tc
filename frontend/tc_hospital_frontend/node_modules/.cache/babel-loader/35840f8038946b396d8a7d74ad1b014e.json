{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.fromRange = fromRange;\nexports.toRange = toRange;\n\nvar _getDocument = require('get-document');\n\nvar _getDocument2 = _interopRequireDefault(_getDocument);\n\nvar _domSeek = require('dom-seek');\n\nvar _domSeek2 = _interopRequireDefault(_domSeek);\n\nvar _simpleXpathPosition = require('simple-xpath-position');\n\nvar xpath = _interopRequireWildcard(_simpleXpathPosition);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar SHOW_TEXT = 4;\n/**\n * Convert a `Range` to a pair of XPath expressions and offsets.\n *\n * If the optional parameter `root` is supplied, the computed XPath expressions\n * will be relative to it.\n *\n * @param {Range} range The Range to convert.\n * @param {Node} [root] The root context for the XPath expressions.\n * @returns {{start, startOffset, end, endOffset}}\n */\n\nfunction fromRange(range, root) {\n  var sc = range.startContainer;\n  var so = range.startOffset;\n  var ec = range.endContainer;\n  var eo = range.endOffset;\n  var start = xpath.fromNode(sc, root);\n  var end = xpath.fromNode(ec, root);\n  return {\n    start: start,\n    end: end,\n    startOffset: so,\n    endOffset: eo\n  };\n}\n/**\n * Construct a `Range` from the given XPath expressions and offsets.\n *\n * If the optional parameter `root` is supplied, the XPath expressions are\n * evaluated as relative to it.\n *\n * @param {string} startPath An XPath expression for the start container.\n * @param {Number} startOffset The textual offset within the start container.\n * @param {string} endPath An XPath expression for the end container.\n * @param {Number} endOffset The textual offset within the end container.\n * @param {Node} [root] The root context for the XPath expressions.\n * @returns Range\n */\n\n\nfunction toRange(startPath, startOffset, endPath, endOffset, root) {\n  var document = (0, _getDocument2['default'])(root);\n  var sc = xpath.toNode(startPath, root);\n  if (sc === null) throw notFound('start');\n  var si = document.createNodeIterator(sc, SHOW_TEXT);\n  var so = startOffset - (0, _domSeek2['default'])(si, startOffset);\n  sc = si.referenceNode;\n\n  if (!si.pointerBeforeReferenceNode) {\n    if (so > 0) throw indexSize('start');\n    so += sc.length;\n  }\n\n  var ec = xpath.toNode(endPath, root);\n  if (ec === null) throw notFound('end');\n  var ei = document.createNodeIterator(ec, SHOW_TEXT);\n  var eo = endOffset - (0, _domSeek2['default'])(ei, endOffset);\n  ec = ei.referenceNode;\n\n  if (!ei.pointerBeforeReferenceNode) {\n    if (eo > 0) throw indexSize('end');\n    eo += ec.length;\n  }\n\n  var range = document.createRange();\n  range.setStart(sc, so);\n  range.setEnd(ec, eo);\n  return range;\n\n  function notFound(which) {\n    var error = new Error('The ' + which + ' node was not found.');\n    error.name = 'NotFoundError';\n    return error;\n  }\n\n  function indexSize(which) {\n    var error = new Error('There is no text at the requested ' + which + ' offset.');\n    error.name = 'IndexSizeError';\n    return error;\n  }\n}","map":{"version":3,"sources":["../src/range.js"],"names":["xpath","SHOW_TEXT","fromRange","sc","range","so","ec","eo","start","end","startOffset","endOffset","toRange","document","notFound","si","indexSize","ei","error"],"mappings":"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","sourcesContent":["import getDocument from 'get-document'\nimport seek from 'dom-seek'\nimport * as xpath from 'simple-xpath-position'\n\nconst SHOW_TEXT = 4\n\n\n/**\n * Convert a `Range` to a pair of XPath expressions and offsets.\n *\n * If the optional parameter `root` is supplied, the computed XPath expressions\n * will be relative to it.\n *\n * @param {Range} range The Range to convert.\n * @param {Node} [root] The root context for the XPath expressions.\n * @returns {{start, startOffset, end, endOffset}}\n */\nexport function fromRange(range, root) {\n  let sc = range.startContainer\n  let so = range.startOffset\n  let ec = range.endContainer\n  let eo = range.endOffset\n\n  let start = xpath.fromNode(sc, root)\n  let end = xpath.fromNode(ec, root)\n\n  return {\n    start: start,\n    end: end,\n    startOffset: so,\n    endOffset: eo,\n  }\n}\n\n\n/**\n * Construct a `Range` from the given XPath expressions and offsets.\n *\n * If the optional parameter `root` is supplied, the XPath expressions are\n * evaluated as relative to it.\n *\n * @param {string} startPath An XPath expression for the start container.\n * @param {Number} startOffset The textual offset within the start container.\n * @param {string} endPath An XPath expression for the end container.\n * @param {Number} endOffset The textual offset within the end container.\n * @param {Node} [root] The root context for the XPath expressions.\n * @returns Range\n */\nexport function toRange(startPath, startOffset, endPath, endOffset, root) {\n  let document = getDocument(root)\n\n  let sc = xpath.toNode(startPath, root)\n  if (sc === null) throw notFound('start')\n\n  let si = document.createNodeIterator(sc, SHOW_TEXT)\n  let so = startOffset - seek(si, startOffset)\n\n  sc = si.referenceNode\n  if (!si.pointerBeforeReferenceNode) {\n    if (so > 0) throw indexSize('start')\n    so += sc.length\n  }\n\n  let ec = xpath.toNode(endPath, root)\n  if (ec === null) throw notFound('end')\n\n  let ei = document.createNodeIterator(ec, SHOW_TEXT)\n  let eo = endOffset - seek(ei, endOffset)\n\n  ec = ei.referenceNode\n  if (!ei.pointerBeforeReferenceNode) {\n    if (eo > 0) throw indexSize('end')\n    eo += ec.length\n  }\n\n  let range = document.createRange()\n  range.setStart(sc, so)\n  range.setEnd(ec, eo)\n\n  return range\n\n  function notFound(which) {\n    let error = new Error(`The ${which} node was not found.`)\n    error.name = 'NotFoundError'\n    return error\n  }\n\n  function indexSize(which) {\n    let error = new Error(`There is no text at the requested ${which} offset.`)\n    error.name = 'IndexSizeError'\n    return error\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
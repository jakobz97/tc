{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports['default'] = seek;\n\nvar _ancestors = require('ancestors');\n\nvar _ancestors2 = _interopRequireDefault(_ancestors);\n\nvar _indexOf = require('index-of');\n\nvar _indexOf2 = _interopRequireDefault(_indexOf);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar E_SHOW = 'Argument 1 of seek must use filter NodeFilter.SHOW_TEXT.';\nvar E_WHERE = 'Argument 2 of seek must be a number or a Text Node.';\nvar SHOW_TEXT = 4;\nvar TEXT_NODE = 3;\n\nfunction seek(iter, where) {\n  if (iter.whatToShow !== SHOW_TEXT) {\n    throw new Error(E_SHOW);\n  }\n\n  var count = 0;\n  var node = iter.referenceNode;\n  var predicates = null;\n\n  if (isNumber(where)) {\n    predicates = {\n      forward: function forward() {\n        return count < where;\n      },\n      backward: function backward() {\n        return count > where;\n      }\n    };\n  } else if (isText(where)) {\n    var forward = before(node, where) ? function () {\n      return false;\n    } : function () {\n      return node !== where;\n    };\n\n    var backward = function backward() {\n      return node != where || !iter.pointerBeforeReferenceNode;\n    };\n\n    predicates = {\n      forward: forward,\n      backward: backward\n    };\n  } else {\n    throw new Error(E_WHERE);\n  }\n\n  while (predicates.forward() && (node = iter.nextNode()) !== null) {\n    count += node.nodeValue.length;\n  }\n\n  while (predicates.backward() && (node = iter.previousNode()) !== null) {\n    count -= node.nodeValue.length;\n  }\n\n  return count;\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseInt(n)) && isFinite(n);\n}\n\nfunction isText(node) {\n  return node.nodeType === TEXT_NODE;\n}\n\nfunction before(ref, node) {\n  if (ref === node) return false;\n  var common = null;\n  var left = [ref].concat((0, _ancestors2['default'])(ref)).reverse();\n  var right = [node].concat((0, _ancestors2['default'])(node)).reverse();\n\n  while (left[0] === right[0]) {\n    common = left.shift();\n    right.shift();\n  }\n\n  left = left[0];\n  right = right[0];\n  var l = (0, _indexOf2['default'])(common.childNodes, left);\n  var r = (0, _indexOf2['default'])(common.childNodes, right);\n  return l > r;\n}","map":{"version":3,"sources":["../src/index.js"],"names":["E_SHOW","E_WHERE","SHOW_TEXT","TEXT_NODE","seek","iter","count","node","predicates","isNumber","forward","backward","isText","isNaN","parseInt","isFinite","ref","common","left","right","l","r"],"mappings":"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","sourcesContent":["import ancestors from 'ancestors'\nimport indexOf from 'index-of'\n\nconst E_SHOW = 'Argument 1 of seek must use filter NodeFilter.SHOW_TEXT.'\nconst E_WHERE = 'Argument 2 of seek must be a number or a Text Node.'\n\nconst SHOW_TEXT = 4\nconst TEXT_NODE = 3\n\n\nexport default function seek(iter, where) {\n  if (iter.whatToShow !== SHOW_TEXT) {\n    throw new Error(E_SHOW)\n  }\n\n  let count = 0\n  let node = iter.referenceNode\n  let predicates = null\n\n  if (isNumber(where)) {\n    predicates = {\n      forward: () => count < where,\n      backward: () => count > where,\n    }\n  } else if (isText(where)) {\n    let forward = before(node, where) ? () => false : () => node !== where\n    let backward = () => node != where || !iter.pointerBeforeReferenceNode\n    predicates = {forward, backward}\n  } else {\n    throw new Error(E_WHERE)\n  }\n\n  while (predicates.forward() && (node = iter.nextNode()) !== null) {\n    count += node.nodeValue.length\n  }\n\n  while (predicates.backward() && (node = iter.previousNode()) !== null) {\n    count -= node.nodeValue.length\n  }\n\n  return count\n}\n\n\nfunction isNumber(n) {\n  return !isNaN(parseInt(n)) && isFinite(n)\n}\n\n\nfunction isText(node) {\n  return node.nodeType === TEXT_NODE\n}\n\n\nfunction before(ref, node) {\n  if (ref === node) return false\n\n  let common = null\n  let left = [ref].concat(ancestors(ref)).reverse()\n  let right = [node].concat(ancestors(node)).reverse()\n\n  while (left[0] === right[0]) {\n    common = left.shift()\n    right.shift()\n  }\n\n  left = left[0]\n  right = right[0]\n\n  let l = indexOf(common.childNodes, left)\n  let r = indexOf(common.childNodes, right)\n\n  return l > r\n}\n"]},"metadata":{},"sourceType":"script"}
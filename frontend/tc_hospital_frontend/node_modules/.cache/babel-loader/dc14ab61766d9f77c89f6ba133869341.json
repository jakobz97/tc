{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.fromNode = fromNode;\nexports.toNode = toNode;\n\nvar _getDocument = require('get-document');\n\nvar _getDocument2 = _interopRequireDefault(_getDocument);\n\nvar _domException = require('./dom-exception');\n\nvar _domException2 = _interopRequireDefault(_domException);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n} // https://developer.mozilla.org/en-US/docs/XPathResult\n\n\nvar FIRST_ORDERED_NODE_TYPE = 9; // Default namespace for XHTML documents\n\nvar HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n/**\n * Compute an XPath expression for the given node.\n *\n * If the optional parameter `root` is supplied, the computed XPath expression\n * will be relative to it. Otherwise, the root element is the root of the\n * document to which `node` belongs.\n *\n * @param {Node} node The node for which to compute an XPath expression.\n * @param {Node} [root] The root context for the XPath expression.\n * @returns {string}\n */\n\nfunction fromNode(node) {\n  var root = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n  if (node === undefined) {\n    throw new Error('missing required parameter \"node\"');\n  }\n\n  root = root || (0, _getDocument2['default'])(node);\n  var path = '/';\n\n  while (node !== root) {\n    if (!node) {\n      var message = 'The supplied node is not contained by the root node.';\n      var name = 'InvalidNodeTypeError';\n      throw new _domException2['default'](message, name);\n    }\n\n    path = '/' + nodeName(node) + '[' + nodePosition(node) + ']' + path;\n    node = node.parentNode;\n  }\n\n  return path.replace(/\\/$/, '');\n}\n/**\n * Find a node using an XPath relative to the given root node.\n *\n * The XPath expressions are evaluated relative to the Node argument `root`.\n *\n * If the optional parameter `resolver` is supplied, it will be used to resolve\n * any namespaces within the XPath.\n *\n * @param {string} path An XPath String to evaluate.\n * @param {Node} root The root context for the XPath expression.\n * @returns {Node|null} The first matching Node or null if none is found.\n */\n\n\nfunction toNode(path, root) {\n  var resolver = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n  if (path === undefined) {\n    throw new Error('missing required parameter \"path\"');\n  }\n\n  if (root === undefined) {\n    throw new Error('missing required parameter \"root\"');\n  } // Make the path relative to the root, if not the document.\n\n\n  var document = (0, _getDocument2['default'])(root);\n  if (root !== document) path = path.replace(/^\\//, './'); // Make a default resolver.\n\n  var documentElement = document.documentElement;\n\n  if (resolver === null && documentElement.lookupNamespaceURI) {\n    (function () {\n      var defaultNS = documentElement.lookupNamespaceURI(null) || HTML_NAMESPACE;\n\n      resolver = function resolver(prefix) {\n        var ns = {\n          '_default_': defaultNS\n        };\n        return ns[prefix] || documentElement.lookupNamespaceURI(prefix);\n      };\n    })();\n  }\n\n  return resolve(path, root, resolver);\n} // Get the XPath node name.\n\n\nfunction nodeName(node) {\n  switch (node.nodeName) {\n    case '#text':\n      return 'text()';\n\n    case '#comment':\n      return 'comment()';\n\n    case '#cdata-section':\n      return 'cdata-section()';\n\n    default:\n      return node.nodeName.toLowerCase();\n  }\n} // Get the ordinal position of this node among its siblings of the same name.\n\n\nfunction nodePosition(node) {\n  var name = node.nodeName;\n  var position = 1;\n\n  while (node = node.previousSibling) {\n    if (node.nodeName === name) position += 1;\n  }\n\n  return position;\n} // Find a single node with XPath `path`\n\n\nfunction resolve(path, root, resolver) {\n  try {\n    // Add a default value to each path part lacking a prefix.\n    var nspath = path.replace(/\\/(?!\\.)([^\\/:\\(]+)(?=\\/|$)/g, '/_default_:$1');\n    return platformResolve(nspath, root, resolver);\n  } catch (err) {\n    return fallbackResolve(path, root);\n  }\n} // Find a single node with XPath `path` using the simple, built-in evaluator.\n\n\nfunction fallbackResolve(path, root) {\n  var steps = path.split(\"/\");\n  var node = root;\n\n  while (node) {\n    var step = steps.shift();\n    if (step === undefined) break;\n    if (step === '.') continue;\n\n    var _step$split = step.split(/[\\[\\]]/);\n\n    var name = _step$split[0];\n    var position = _step$split[1];\n    name = name.replace('_default_:', '');\n    position = position ? parseInt(position) : 1;\n    node = findChild(node, name, position);\n  }\n\n  return node;\n} // Find a single node with XPath `path` using `document.evaluate`.\n\n\nfunction platformResolve(path, root, resolver) {\n  var document = (0, _getDocument2['default'])(root);\n  var r = document.evaluate(path, root, resolver, FIRST_ORDERED_NODE_TYPE, null);\n  return r.singleNodeValue;\n} // Find the child of the given node by name and ordinal position.\n\n\nfunction findChild(node, name, position) {\n  for (node = node.firstChild; node; node = node.nextSibling) {\n    if (nodeName(node) === name && --position === 0) break;\n  }\n\n  return node;\n}","map":{"version":3,"sources":["../src/xpath.js"],"names":["FIRST_ORDERED_NODE_TYPE","HTML_NAMESPACE","fromNode","root","node","path","message","name","nodeName","nodePosition","toNode","resolver","document","documentElement","defaultNS","ns","resolve","position","nspath","platformResolve","fallbackResolve","steps","step","parseInt","findChild","r"],"mappings":"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","sourcesContent":["import getDocument from 'get-document'\n\nimport DOMException from './dom-exception'\n\n// https://developer.mozilla.org/en-US/docs/XPathResult\nconst FIRST_ORDERED_NODE_TYPE = 9\n\n// Default namespace for XHTML documents\nconst HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml'\n\n\n/**\n * Compute an XPath expression for the given node.\n *\n * If the optional parameter `root` is supplied, the computed XPath expression\n * will be relative to it. Otherwise, the root element is the root of the\n * document to which `node` belongs.\n *\n * @param {Node} node The node for which to compute an XPath expression.\n * @param {Node} [root] The root context for the XPath expression.\n * @returns {string}\n */\nexport function fromNode(node, root = null) {\n  if (node === undefined) {\n    throw new Error('missing required parameter \"node\"')\n  }\n\n  root = root || getDocument(node)\n\n  let path = '/'\n  while (node !== root) {\n    if (!node) {\n      let message = 'The supplied node is not contained by the root node.'\n      let name = 'InvalidNodeTypeError'\n      throw new DOMException(message, name)\n    }\n    path = `/${nodeName(node)}[${nodePosition(node)}]${path}`\n    node = node.parentNode\n  }\n  return path.replace(/\\/$/, '')\n}\n\n\n/**\n * Find a node using an XPath relative to the given root node.\n *\n * The XPath expressions are evaluated relative to the Node argument `root`.\n *\n * If the optional parameter `resolver` is supplied, it will be used to resolve\n * any namespaces within the XPath.\n *\n * @param {string} path An XPath String to evaluate.\n * @param {Node} root The root context for the XPath expression.\n * @returns {Node|null} The first matching Node or null if none is found.\n */\nexport function toNode(path, root, resolver = null) {\n  if (path === undefined) {\n    throw new Error('missing required parameter \"path\"')\n  }\n  if (root === undefined) {\n    throw new Error('missing required parameter \"root\"')\n  }\n\n  // Make the path relative to the root, if not the document.\n  let document = getDocument(root)\n  if (root !== document) path = path.replace(/^\\//, './')\n\n  // Make a default resolver.\n  let documentElement = document.documentElement\n  if (resolver === null && documentElement.lookupNamespaceURI) {\n    let defaultNS = documentElement.lookupNamespaceURI(null) || HTML_NAMESPACE\n    resolver = (prefix) => {\n      let ns = {'_default_': defaultNS}\n      return ns[prefix] || documentElement.lookupNamespaceURI(prefix)\n    }\n  }\n\n  return resolve(path, root, resolver)\n}\n\n\n// Get the XPath node name.\nfunction nodeName(node) {\n  switch (node.nodeName) {\n  case '#text': return 'text()'\n  case '#comment': return 'comment()'\n  case '#cdata-section': return 'cdata-section()'\n  default: return node.nodeName.toLowerCase()\n  }\n}\n\n\n// Get the ordinal position of this node among its siblings of the same name.\nfunction nodePosition(node) {\n  let name = node.nodeName\n  let position = 1\n  while ((node = node.previousSibling)) {\n    if (node.nodeName === name) position += 1\n  }\n  return position\n}\n\n\n// Find a single node with XPath `path`\nfunction resolve(path, root, resolver) {\n  try {\n    // Add a default value to each path part lacking a prefix.\n    let nspath = path.replace(/\\/(?!\\.)([^\\/:\\(]+)(?=\\/|$)/g, '/_default_:$1')\n    return platformResolve(nspath, root, resolver)\n  } catch (err) {\n    return fallbackResolve(path, root)\n  }\n}\n\n\n// Find a single node with XPath `path` using the simple, built-in evaluator.\nfunction fallbackResolve(path, root) {\n  let steps = path.split(\"/\")\n  let node = root\n  while (node) {\n    let step = steps.shift()\n    if (step === undefined) break\n    if (step === '.') continue\n    let [name, position] = step.split(/[\\[\\]]/)\n    name = name.replace('_default_:', '')\n    position = position ? parseInt(position) : 1\n    node = findChild(node, name, position)\n  }\n  return node\n}\n\n\n// Find a single node with XPath `path` using `document.evaluate`.\nfunction platformResolve(path, root, resolver) {\n  let document = getDocument(root)\n  let r = document.evaluate(path, root, resolver, FIRST_ORDERED_NODE_TYPE, null)\n  return r.singleNodeValue\n}\n\n\n// Find the child of the given node by name and ordinal position.\nfunction findChild(node, name, position) {\n  for (node = node.firstChild ; node ; node = node.nextSibling) {\n    if (nodeName(node) === name && --position === 0) break\n  }\n  return node\n}\n"]},"metadata":{},"sourceType":"script"}